# 原程序细节

1.adc采样——使用的是扫描+连续+dma的形式；目前看那个中断是没有用到的

2.主要的程序逻辑在定时3的中断当中——adc采集的数据处理在5ms

3.PWM占空比调节——mppt算法实现的核心程序

当前周期对占空比的+4或者-4，从而来影响下个周期的P 、P\_prev 、 V 、 V\_prev   当前功率、上一周期的功率、当前电压、上一周期的电压

并通过       if(P > P\_prev \&\& V > V\_prev)   扰动方向是否正确

4.程序中的占空比IO\_Para.Duty\_Cycle变量，内的数据并不是一个百分%，而是实际的pwm定时器的比较值CCR，

因为定时器的arr值是720，所以当占空比变量IO\_Para.Duty\_Cycle的值为360时则代表50%

本mppt工程采用的参数有：

占空比 ： 上下限  0-720     ；程序限制占空比\[50，670]

              初始值   会根据设定输出电压与输入电流简单判断

干扰步长：固定步长  4

采样参数计算：输入输出参数采样计算——100ms一次；adc采集则是每84us采集一组4个数据；adc采样精度为12bit

保护：过流、过压欠流欠压与状态机判断——5ms一次

 	输出短路保护 ：短路电流12A  短路电压3V

 	输出过流保护：输出10.5A电流且持续50ms

 	输出过压保护：输出55V电压且持续10ms

 	输入欠压保护：输入电压低于6.8v且持续时长200ms

 	输入过压保护：输入电压高于55v且持续时长100ms

 	输入过功率保护：输入功率高于100w且持续时长100ms

 	状态机：初始化、等待、运行、故障四个状态

# 原程序重点函数

* 旋转编码器左转右转判断函数——unsigned char Encoder(void)——每1ms在中断中判断一次
* LED屏显示逻辑：0级别——编码器旋转控制cur\_position变量，变量cur\_position对应光标在Mode:CC/CV位置、Set:\*\*.\*V位置、\*\*.\*A位置

1级（按下中间按键一次后）——根据变量cur\_position在不同位置可以进行不同的设置（模式切换、目标电压和最大电流设置）

只要检测到编码器旋转就会进入这段程序

* adc数据转换函数——Cal\_IO\_Para(void)，每次处理都是处理4\*300个数据，也就是adc采集完整一轮的数据；但是原始adc采集是使用的dma循环模式，在该模式下dma数据接收数组ADCConvertedValue【】是覆盖不是清零，也就说如果adc采集一轮的时间长于Cal\_IO\_Para(void)的执行间隔，那么会导致adc数据被多次使用（但adc采集需要强行分成几轮几轮嘛，感觉影响不大）——该函数是采用300个数据进行一次平均滤波

# 现整个系统的一些具体参数（时间）

* adc采样，4个通道，每个通道300个数进行平均滤波的滤波函数Cal_IO_Para();执行所需时长——500微秒
* 目前的mppt程序，原本的固定步长扰动mppt所需时间2.8微秒到10微秒之间（占空比调节时稳定耗时2.8微秒，占空比稳定后耗时抖动在4.4微秒到10微秒之间）；
                    变步长PO-MPPT所需时间3.9微秒-4.6微秒之间（基本一启动就进入了稳定状态）
                    电导INC-MPPT所需时间稳定在3微秒（基本一启动就进入了稳定状态）
* 通过旋转编码器按键断开输入输出通路，电压从12v降低至0v所需时间170微秒（测量点是输出的接线端子处）
* 目前mppt学习板定时器初始化时设定死区时间为500ns，实际测量mcu输出pwm死区占空比也为500ns；但是eg2312驱动输出的pwm死区是700ns
* 


# 细节调节点

* PWM波调节——（死区时间、死区补偿——不急）、pwm波开关周期、PWM波的分辨率值
* ADC采样——ADC采样周期、ADC采样时钟、ADC采样方式、ADC数据计算——平均滤波的个数、平均滤波所需要的时间
* adc采样得到的电流电压保留到小数点后几位，不用浮点数每条语句的执行机械周期多少
* 各个状态机、采样函数、mppt算法的调用时间间隔
* 变步长P\&O算法——变步长比例PO\_MPPT\_K
* 
